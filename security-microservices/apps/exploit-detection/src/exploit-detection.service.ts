import { MailerService } from '@nestjs-modules/mailer';
import { Injectable, Logger } from '@nestjs/common';
import { ethers } from 'ethers';
import { ConfigService } from '@nestjs/config';

@Injectable()
export class ExploitDetectionService {
  private readonly logger = new Logger(ExploitDetectionService.name);
  private provider: ethers.WebSocketProvider;
  private contractAddress: string;
  private contractABI = [
    'event Withdrawn(address indexed user, uint256 amount)',
  ];

  constructor(
    private readonly mailService: MailerService,
    private readonly configService: ConfigService,
  ) {
    this.provider = new ethers.WebSocketProvider(this.configService.get<string>('BLOCKCHAIN.WEBSOCKET_URL'));
    this.contractAddress = this.configService.get<string>('BLOCKCHAIN.PROXY_ADDRESS');
  }

  async sendMail(user: string, amount: string) {
    const message = `An attempt to exploit the vulnerability was detected from address ${user} with amount ${amount} ETH.`;
    
    return await this.mailService.sendMail({
      from: 'QuillAudits <quillAudits@demomailtrap.com>',
      to: 'jeneya2244@biscoine.com',
      subject: 'Alert: Possible Exploitation Attempt Detected',
      text: message,
    });
  }

  async monitor() {
    const contract = new ethers.Contract(this.contractAddress, this.contractABI, this.provider);

    contract.on('Withdrawn', async (user: string, amount: ethers.BigNumberish) => {
          
      try {
        const isContract = await this.checkIfContract(user);
        if (isContract) {
          this.logger.log(`Possible exploitation attempt detected from contract ${user} with amount ${ethers.formatEther(amount)} ETH`);
          await this.sendMail(user, ethers.formatEther(amount));
        } else {
          this.logger.log(`Non-contract address detected: ${user} with amount ${ethers.formatEther(amount)} ETH`);
        }
      } catch (error) {
        this.logger.error('Error while handling ExploitationAttempt event', error);
      }
    });
  }

  async checkIfContract(address: string): Promise<boolean> {
    const code = await this.provider.getCode(address);
    return code !== '0x'; // If the code is non-empty, it's a contract
  }

  private async reconnect() {
    try {
      this.provider = new ethers.WebSocketProvider(this.configService.get<string>('BLOCKCHAIN.WEBSOCKET_URL'));
      await this.monitor();
      this.logger.log('Reconnected to WebSocket provider');
    } catch (error) {
      this.logger.error('Reconnection failed', error);
    }
  }
}
