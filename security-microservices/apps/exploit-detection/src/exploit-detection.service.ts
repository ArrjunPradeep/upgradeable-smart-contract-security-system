import { MailerService } from '@nestjs-modules/mailer';
import { Injectable, Logger } from '@nestjs/common';
import { ethers } from 'ethers';
import { ConfigService } from '@nestjs/config';
import { ExploitLog, ExploitLogSchema } from './expolit-detection.schema';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';

@Injectable()
export class ExploitDetectionService {
  // Initialize a logger for the ExploitDetectionService
  private readonly logger = new Logger(ExploitDetectionService.name);

  // Declare a WebSocket provider for connecting to the blockchain network
  private provider: ethers.WebSocketProvider;

  // Declare a contract address for the monitored smart contract
  private contractAddress: string;

  // Define the ABI (Application Binary Interface) for the smart contract events of interest
  private contractABI = [
    'event Withdrawn(address indexed user, uint256 amount)',
  ];

  constructor(
    // Inject the Mongoose model for ExploitLog, used to interact with the database
    @InjectModel(ExploitLog.name) private readonly exploitLogModel: Model<ExploitLog>,

    // Inject the MailerService for sending alert emails
    private readonly mailService: MailerService,

    // Inject the ConfigService to access environment variables
    private readonly configService: ConfigService,
  ) {
    // Initialize the WebSocket provider using the configured blockchain WebSocket URL
    this.provider = new ethers.WebSocketProvider(this.configService.get<string>('BLOCKCHAIN.WEBSOCKET_URL'));

    // Retrieve the proxy contract address from the configuration
    this.contractAddress = this.configService.get<string>('BLOCKCHAIN.PROXY_ADDRESS');
  }

  // Method to send an alert email when an exploit is detected
  async sendMail(user: string, amount: string) {
    // Compose the email message body with details of the detected exploit attempt
    const message = `An attempt to exploit the vulnerability was detected from address ${user} with amount ${amount} ETH.`;

    // Send the email using the MailerService
    return await this.mailService.sendMail({
      from: 'QuillAudits <quillAudits@demomailtrap.com>',
      to: 'jeneya2244@biscoine.com',
      subject: 'Alert: Possible Exploitation Attempt Detected',
      text: message,
    });
  }

  // Method to start monitoring the smart contract for suspicious activities
  async monitor() {
    // Instantiate a contract object with the specified address, ABI, and provider
    const contract = new ethers.Contract(this.contractAddress, this.contractABI, this.provider);

    // Listen for the 'Withdrawn' event emitted by the contract
    contract.on('Withdrawn', async (user: string, amount: ethers.BigNumberish, args) => {

      try {
        // Check if the 'user' address is a smart contract
        const isContract = await this.checkIfContract(user);
        if (isContract) {
          // Define the reason for logging as 'Suspected exploit' if the address is a contract
          const reason = 'Suspected exploit';

          // Store the detected exploit in the database
          const newExploitLog = new this.exploitLogModel({
            from: user,
            reason: reason,
            amount: ethers.formatEther(amount), // Convert the amount to human-readable format (ETH)
            contractAddress: this.contractAddress,
            hash: args.log.transactionHash, // Store the transaction hash
            data: args.log.data // Store the raw log data
          });

          // Save the log entry to the database
          await newExploitLog.save();

          // Log the detection and send an alert email
          this.logger.log(`Possible exploitation attempt detected from contract ${user} with amount ${ethers.formatEther(amount)} ETH`);
          await this.sendMail(user, ethers.formatEther(amount));
        } else {
          // Log non-contract address withdrawals (could be benign)
          this.logger.log(`Non-contract address detected: ${user} with amount ${ethers.formatEther(amount)} ETH`);
        }
      } catch (error) {
        // Log any errors encountered during the event handling
        this.logger.error('Error while handling ExploitationAttempt event', error);
      }
    });
  }

  // Method to check if an address is a smart contract
  async checkIfContract(address: string): Promise<boolean> {
    // Retrieve the code at the specified address (non-empty code indicates a contract)
    const code = await this.provider.getCode(address);
    return code !== '0x'; // If the code is non-empty, it's a contract
  }

  // Method to handle reconnection to the blockchain WebSocket provider
  private async reconnect() {
    try {
      // Reinitialize the WebSocket provider
      this.provider = new ethers.WebSocketProvider(this.configService.get<string>('BLOCKCHAIN.WEBSOCKET_URL'));

      // Restart monitoring the contract
      await this.monitor();

      // Log successful reconnection
      this.logger.log('Reconnected to WebSocket provider');
    } catch (error) {
      // Log any errors during reconnection attempts
      this.logger.error('Reconnection failed', error);
    }
  }
}